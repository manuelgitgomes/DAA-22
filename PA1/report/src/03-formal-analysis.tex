\section{Formal Analysis}\label{section:formal-analysis}
This section will be focused on performing a formal analysis for the algorithm described in \autoref{section:algorithms-used}.
This formal analysis will consist of presenting their basic operations, defining a closed formula for the number of basic operations, their order of growth, and the worst and best cases.

For the exhaustive search algorithm, the basic operation defined is verifying if a set is a dominating set, due to its repetitiveness and computational demand.
This operation takes place for every combination of edges in a graph.
For a generic graph $G(V,E)$ with $m$ vertices and $n$ edges, the combination of edges can be given by a set of binary number with $n$ elements.
Every binary number corresponds to a certain edge. 
When it is zero, the edge is not present in the combination.
When it is one, the edge is present in the combination.
This concept is better illustrated by \autoref{eq:edges} and \autoref{eq:combination}.

\begin{equation}
    edges = [e_1,\ e_2,\ ...,\ e_(n-1),\ e_n]
    \label{eq:edges}
\end{equation}

\begin{equation}
    combination = [0,\ 1,\ ...,\ 1,\ 0],\ \text{with length }n
    \label{eq:combination}
\end{equation}

So, if every combination can be defined by a set of binary numbers with length $n$, it can be concluded that the closed formula for the number of basic operations is given by \autoref{eq:ex-closed-formula}.

\begin{equation}
    T(n) = 2^n
    \label{eq:ex-closed-formula}
\end{equation}

Therefore, we conclude the order of magnitude of the algorithm is exponential, as seen in \autoref{eq:ex-big-o}.

\begin{equation}
    O(n) = 2^n
    \label{eq:ex-big-o}
\end{equation}

As the algorithm always needs to verify every single combination, the best and worst case scenario are given by \autoref{eq:ex-worst} and \autoref{eq:ex-best}.

\begin{equation}
    W(n) = 2^n
    \label{eq:ex-worst}
\end{equation}
\begin{equation}
    B(n) = 2^n
    \label{eq:ex-best}
\end{equation}

For the greedy heuristics, the basic operation defined is the sorting of the lists of edges, due to behind the most time consuming operation.
The sorting algorithm used was the \verb|sort()| function in Python 3, which according to documentation \cite{sortpython}, has a order of magnitude given by \autoref{eq:greedy-big-o}.

\begin{equation}
    O(n) = nlog_2(n)
    \label{eq:greedy-big-o}
\end{equation}

Regarding the best and worst case scenario, the algorithm can found an adequate solution after one iteration or after iterating for every edge.
Therefore, the best and worst cases can be defined by \autoref{eq:greedy-worst} and \autoref{eq:greedy-best}.

\begin{equation}
    W(n) = n
    \label{eq:greedy-worst}
\end{equation}
\begin{equation}
    B(n) = 1
    \label{eq:greedy-best}
\end{equation}